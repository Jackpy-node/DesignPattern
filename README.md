# DesignPattern

## 设计模式六大原则
1. 开闭原则：对扩展开放，对修改关闭
2. 里氏代换原则：任何基类可以出现的地方，子类一定可以出现
3. 依赖倒转原则：针对接口编程，依赖于抽象而不依赖于具体
4. 接口隔离原则：使用多个隔离的接口，比使用单个接口更好，降低类之间的耦合性
5. 迪米特原则（最少知道原则）：一个实体应尽量减少与其他实体之间的相互作用，使得系统功能模块相互独立
6. 合成复用原则：尽量使用合成/聚合的方式，而不是使用继承

## 创建型设计模式
+ 提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活
### FactoryPattern：工厂模式
+ 抽取某种对象共同属性，定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行
### AbstractFactoryPattern：抽象工程模式
+ 抽象工厂通过抽象类的方式，将多个简单工厂进行包装，对外提供抽象方法，抽象工厂指定不同的参数调用抽象类的不同的抽象方法，根据需求产生不同的对象
### SingletonPattern：单例模式
+ 保证一个类仅有一个实例，全局使用的实例对象
###BuilderPattern：建造者模式
+ 由很多个简单对象逐步构造成可以实现复杂功能的对象
###PrototypePattern：原型模式
+ 通过原型实例指定创建对象的种类，后续通过cloneable接口中的clone()方法，实现与原型对象一样的实例

## 结构型设计模式
+ 关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式
### AdapterPattern：适配器模式
+ 将多个不兼容的接口进行整合，对外提供统一入口，适配器根据不同需求创建不同的对象实现具体功能
### BridgePattern：桥接模式
+ 将抽象化与实现化解耦，降低类之间的耦合性，便于更好扩展
### FilterPattern：过滤器模式
+ 创建过滤器接口之后，继承该过滤器的子类实现其抽象方法，实现子类特有的筛选方式，通过对多个子类组合可以构造出复杂过滤器，该模式的最终结果是通过单个或多个条件对已有对象进行筛选
### CompositePattern：组合模式
+ 组合模式依据树形结构来组合对象，用来表示部分以及整体层次
### DecoratorPattern：装饰模式
+ 允许向一个现有的对象添加新的功能，同时又不改变其结构
### FacadePattern：外观模式
+ 隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口
### FlyweightPattern：享元模式
+ 减少创建对象的数量，以减少内存占用和提高性能
### ProxyPattern：代理模式
+ 用另外一个类的功能代表当前类的功能

## 行为型设计模式
+ 特别关注对象之间的通信
### ChainPattern：责任链模式
+ 为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦
### CommandPattern：命令模式
+ 请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令
### InterpretPattern：解释器模式
+ 实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等
### IteratorPattern：迭代器模式
+ 用于顺序访问集合对象的元素，不需要知道集合对象的底层表示
### MediatorPattern：中介者模式
+ 通常处理不同类之间的通信，并支持松耦合，使代码易于维护，降低多个对象和类之间的通信复杂性
### MementoPattern： 备忘录模式
+ 保存一个对象的某个状态，以便在适当的时候恢复对象
### ObserverPattern：观察者模式
+ 当一个对象被修改时，则会自动通知它的依赖对象，观察主导对象，当主导对象发生改变时，观察者随之改变；可理解为：观察别人，改变自己
### StatePattern：状态模式
+ 类的行为是基于它的状态改变的，状态模式表示了具有某种状态的实体的状态行为变化过程
### NullObjectPattern：空对象模式
+ 一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为
### StrategyPattern：策略模式
+ 一个类的行为或其算法可以在运行时更改，策略模式表示了具有某种操作的实体对象在运行时，根据条件选择不同的执行策略，执行不同的算法
### TemplatePattern：模板模式
+ 一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行
### VisitorPattern：访问者模式
+ 使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变；需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类

## J2EE模式
+ 特别关注表示层
### MCVPattern：Model-View-Controller（模型-试图-控制器）模式
&emsp; 用于应用程序的分层开发
+ Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。
+ View（视图） - 视图代表模型包含的数据的可视化。
+ Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开
### BusinessDelegatePattern：业务代表模式
&emsp; 用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能，在业务层中我们有以下实体：
+ 客户端（Client） - 表示层代码可以是 JSP、servlet 或 UI java 代码。
+ 业务代表（Business Delegate） - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。
+ 查询服务（LookUp Service） - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。
+ 业务服务（Business Service） - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。
### CompositeEntityPattern：组合实体模式
&emsp; 组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者：
+ 组合实体（Composite Entity） - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。
+ 粗粒度对象（Coarse-Grained Object） - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。
+ 依赖对象（Dependent Object） - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。
+ 策略（Strategies） - 策略表示如何实现组合实体。
### FrontControllerPattern：前端控制模式
&emsp; 前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。
+ 前端控制器（Front Controller） - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。
+ 调度器（Dispatcher） - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。
+ 视图（View） - 视图是为请求而创建的对象。
### InterceptingFilterPattern：拦截过滤器模式
&emsp; 拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体：
+ 过滤器（Filter） - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。
+ 过滤器链（Filter Chain） - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。
+ Target - Target 对象是请求处理程序。
+ 过滤管理器（Filter Manager） - 过滤管理器管理过滤器和过滤器链。
+ 客户端（Client） - Client 是向 Target 对象发送请求的对象。
### ServiceLocatorPattern：服务定位器模式
&emsp; 服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体：
+ 服务（Service） - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。
+ Context / 初始的 Context - JNDI Context 带有对要查找的服务的引用。
+ 服务定位器（Service Locator） - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。
+ 缓存（Cache） - 缓存存储服务的引用，以便复用它们。
+ 客户端（Client） - Client 是通过 ServiceLocator 调用服务的对象。
### DAOPattern：Data-Access-Object（数据访问对象）模式
&emsp; 数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者：
+ 数据访问对象接口（Data Access Object Interface） - 该接口定义了在一个模型对象上要执行的标准操作。
+ 数据访问对象实体类（Data Access Object concrete class） - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。
+ 模型对象/数值对象（Model Object/Value Object） - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。
### TransferObjectPattern：传输对象模式
&emsp; 传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体：
+ 业务对象（Business Object） - 为传输对象填充数据的业务服务。
+ 传输对象（Transfer Object） - 简单的 POJO，只有设置/获取属性的方法。
+ 客户端（Client） - 客户端可以发送请求或者发送传输对象到业务对象。
